@(maxItem: Int)

package xio.helper

object XIOErrorHelperInstance {

    @for(i <- 1 to maxItem) {
        trait MatchAll1Apply@{i}[P <: xio.nat.error.NatEither @for(ii <- 1 to i) { , E@{ii} }, Input <: xio.nat.has.Nat, Out] {
            def input@{i}(@for(ii <- 1 to i) { @if(ii > 1) { , } e@{ii}: xio.ErrorContent[E@{ii}, P, Input, Out] => xio.XIO[Input, P, Out] }): xio.XIO[Input, P, Out]
        }
    }

}

trait XIOErrorHelper {

    implicit class XIOErrorMatchAll1ImplicitClass1[X <: xio.nat.has.Nat, E1, I](i: xio.XIO[X, xio.XError1[E1], I]) {
        def allError[P <: xio.nat.error.NatEither]: XIOErrorHelperInstance.MatchAll1Apply1[P, E1, X, I] =
            new XIOErrorHelperInstance.MatchAll1Apply1[P, E1, X, I] {
                override def input1(e1: xio.ErrorContent[E1, P, X, I] => xio.XIO[X, P, I]): xio.XIO[X, P, I] =
            XIOHelper.simpleCatchAll(i) { n => e1(new xio.ErrorContentImpl(n.sureRight)) }
        }
    }

    @for(i <- 2 to maxItem) {
        implicit class XIOErrorMatchAll1ImplicitClass@{i}[X <: xio.nat.has.Nat @for(ii <- 1 to i) { , E@{ii} }, I](i: xio.XIO[X, xio.XError@{i}[ @for(ii <- 1 to i) { @if(ii > 1) { , } E@{ii} } ], I]) {
            def allError[P <: xio.nat.error.NatEither]: XIOErrorHelperInstance.MatchAll1Apply@{i}[P @for(ii <- 1 to i) { , E@{ii} }, X, I] = new XIOErrorHelperInstance.MatchAll1Apply@{i}[P @for(ii <- 1 to i) { , E@{ii} }, X, I] {
                override def input@{i}(@for(ii <- 1 to i) { @if(ii > 1) { , } e@{ii}: xio.ErrorContent[E@{ii}, P, X, I] => xio.XIO[X, P, I] }): xio.XIO[X, P, I] = 1.asInstanceOf[xio.XIO[X, P, I]]
            }
        }
    }

}
